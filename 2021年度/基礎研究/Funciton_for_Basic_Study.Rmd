---
title: "基礎研究用の関数まとめ"
author: "Nishimura Tsubasa"
date: "2022/1/9"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

このファイルは，基礎研究の分析に必要となる関数をまとめたものである．  
具体的には，Life Ruin Probabilty（LRP）の高度化を目的とし，必要な関数を作成・修正したものである．

<br />

#### ゴンパーツモデルパラメータのカリブレーション

ここでは，最頻値を与えることで，ゴムパーツ分布の解析解とシミュレーションによる数値解の絶対偏差の和を計算するための関数を定義している．

```{r}
CalibrationParmb <- function(par){
  # par:ゴムパーツモデルのパラメータ（最頻値，散布度計数）
  gap <- c()
  for (i in 1: (110-x)){
    gap[i] <- abs(TPXG(x, o , par[1], par[2]) - SPQR(x, x+i, qx))
  }
  sum(gap)
}
```

$par:ゴンパーツモデルにおけるmとbをベクトル表記したもの$

<br />

#### ゴンパーツモデルの仮定の下で生存率を求める関数．

```{r}
TPXG <- function(x, t, m, b){
  exp(exp((x-m)/b)*(1-exp(t/b)))
}
```

$x:現在の年齢$  
$t:時間$  
$m:ゴンパーツパラメータ，最頻値$  
$b:ゴンパーツモデルパラメータ，分散係数$  

<br />

#### 死亡率のベクトル表記．
実データから得られる死亡率をベクトル表記するための関数．

```{r}
SPQR <- function(x, y, qx){
  LT <- cumprod(1-qx) # 全要素の累積和を計算
  LT <- c(1,LT)
  LT[y+1] / LT[x+1]
}
```

$y:求めたい生存率の年齢$

<br />

#### ゴンパーツ乱数（時点のシミュレーション）を生成する関数．

死力モデルとしてGompertzモデルを仮定する．人間の余命は以下で評価する．
$$
T_{\iota} = b \rm{ln} \left[ 1 - \rm{ln} [_{T_\iota}p_0] e^{(\iota-m)/b} \right]
$$

それゆえ，$_tp_0$を与えることで，人間の余命をシミュレーションすることができる．ここでは，$_tp_0$を一様分布として　シミュレーションすることで，逆関数法によってGompertzモデルに従う人間の余命$T_\iota$をシミュレーションすることが可能．以下の関数は，$T_{\iota}$を評価するための関数．


```{r}
GRAN <- function(N, x, m, b){
  b*log(1-log(runif(N))*exp((m-x)/b))
}
```

rXXX()は乱数を発生させる関数であり，unifは一様分布を表す．つまりuinif$(N,min,max)$の$N$は試行回数の一様乱数を発生させるものである．ただし，$min$は出力する乱数の最小値，$max$は出力する乱数の最大値を表す．

<br />

#### LRPをシミュレーションするための関数
上期基礎研究報告書の$(74)$式にある式を離散化して評価したものである．
具体的な説明は以下の通り．

<br />

収益率$\nu$が確率的である場合，LHPは以下で評価することができる．
$$
\varphi = \rm{Pr}\left[ \frac{1}{\xi}\leq\int_0^{T_\iota}Z_s^{-1}\rm{ds}\right]
$$
ここで，$Z_s$はポートフォリオの確率的な変動を表す．ただし$B_t$はブラウン運動である．
$$
Z_s = e^{\nu{s}+\sigma{B_s}} 
$$

離散化して評価しているが，ここの$\nu$と$\sigma$をベクトル表記に修正．  補足として，式に含まれている$52$は，年率データを週次に変換しているものである．

```{r}
VARPHI.SM <- function(N, x, m, b, xi, nu, sigma){
  V <- c()
  wks <- round(GRAN)
  for (i in 1:N){
    sB <- sigma*sqrt(1/52) * cumsum(rnorm(wks[i])) # 累積和プラスアルファ
    Z <- exp((nu/52) * c(1:(wks[i])) + sB)
    V[i] <- sum((1/Z)/52)
  }
  sum(V>=1/xi)/length(V)
}
```

$x_i:支出率$  
$\nu:投資収益率の期待値$  
$\sigma:投資収益率の標準偏差$  

<br />

#### ポートフォリオの余命を寿命をシミュレーションするための関数
ポートフォリオの余命とは，金融資本が消費によって0以下となる時点のことである．すなわち，金融資本の現在価値と消費系列の現在価値が等しくなる時点を指す．  
現在時点における金融資本を$F_0$とすると，$F_0=0$となる時点がポートフォリオの余命である．
$$
F_0=\int_{0}^{L_\xi}ce^{-\nu t}dt=\frac{c}{\nu}(1-e^{-\nu L_\xi})
$$

$L_\xi:ポートフォリオの余命$  
$\xi:現在時点における消費率(\xi=c/F_0)$  
$\nu:ポートフォリオの収益率$


ここで，$c/F_0>\xi$のとき，以下の通りになる．

$$
L_\xi = \frac{1}{\nu}\rm{ln}\left[\frac{\xi}{\xi-\nu}\right]
$$

前回やっていた「ポートフォリオの余命シミュレーションアルゴリズム」は，1年間の連続複利収益率$\nu_i$を$N(\mu,\sigma)$としてシミュレーションをしていた．
今回は，ここを実際ポートフォリオを組んだ場合における「期待収益率」を用いて分析を行っていく．  
やることとしては，期待収益率を算出する関数を作成する必要がある．
$N(\mu,\sigma)$に従う乱数を発生させているが，ここでの期待収益率$\mu$，$\sigma$を時点$t$に依存するように変更させる．
なので，代入している箇所（137行目）をベクトルに変換．

```{r}
PLSM <- function(F, c, m, b, xi, nu, sigma){
  path <- matrix(nrow = N, ncol = 100)
  return <- matrix(nrow = N, ncol = 99)
  PLV <- c()
  for (i in 1:N){  # 添字iはシミュレーションの数字
    path[i, 1] <- F　# 初期時点の資産額はFとする
    for (j in 2:100){
      return[i, j] <- exp(rnorm(100, nu[j], sigma[j]))
      path[i, j] <- path[i,j-1] * return[j] - c
      if (path[i,j]<=0) {break}
    }
    PLV[i]=j
  }
  PLV
}
```

<br/>

#### ウェイトを変化させる関数
臼杵さんの論文では，以下の4つのパタンにて検証している．  
1.（100%-実年齢）%  
2.（65-実年齢）%  
3. 56％  
4. 12%  

引数を「初期時点における株式のウェイト」，「死亡年齢」，「現在の年齢」としておく．  

```{r}
CalcWeight <- function(w, Tx, x){
  scock <- c()
  bonds <- c()
  t <- Tx-x
  for (i in 1:t){
    stock[i] <- w-(i+x)
    bonds[i] <- 100-stock[i]
    if (stock[i]<=0) {break}
  }
}
```

$w:初期時点における株式ウェイト（w=100,65）$  
$stock:時点における株式ウェイト$  
$bonds:時点における債券ウェイト$

<br/>


